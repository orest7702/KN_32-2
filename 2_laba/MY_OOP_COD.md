### Мета роботи: Начитись використовувати основні принципи ООП, розглянути кострукції побудови класу та створення обєтів та навчитись працювати з ними
---
###### (Я спробував самостійно опрацювати дану тему і ось що у мене получилось [тут](OOP.py) код який я сам написав, в якому описано клас на подобі функціонального програмування описвного [тут](https://github.com/BobasB/2025_kn32_oop/blob/main/3_lab/note.ipynb))
---
На парі ми розглядали функціональне та Обєктно Орієнтоване Програмування(ООП), розглянули основні відмінності між ними, а також основні принципи ООП:
Першим кроком ми розробили невелику гру в функціональному стилі, а потім переробили її в ООП стилі.
---
ось код функціонального стилю:
```python
import random
names = ["Мечик", "Шпага", "Сокирка", "Спис"]
magic_types = ["Вогонь", "Земля", "Вода", "Вітер"]

def draw_card():
    item = {
        "name": random.choice(names),
        "attack_power": random.randint(4, 8),
        "durability": random.randint(30, 60),
        "magic_attribute": f"Магія: {random.choice(magic_types)}"
    }
    return item

player_1 = list()
player_2 = list()


for move in range(3):
    print("Гравець 1 робить хід:")
    player_1.append(draw_card())
    print("Гравець 2 робить хід:")
    player_2.append(draw_card())

print(f"""Карти у руці гравця 1:
        {player_1}
    Карти у руці гравця 2:
        {player_2}
      """)

def check_if_player_has_cards(list_of_cards: list) -> bool:
    return True if len(list_of_cards) >= 1 else False


for move in range(3):
    if check_if_player_has_cards(player_1):
        card_on_board_1 = player_1.pop()
    else:
        print("У гравця 1 не залишилось карт")
    
    if check_if_player_has_cards(player_2):
        card_on_board_2 = player_2.pop()
    else:
        print("У гравця 2 не залишилось карт")

    while card_on_board_1['durability'] > 0 or card_on_board_2['durability'] > 0:
        card_on_board_1['durability'] -= card_on_board_2["attack_power"]
        card_on_board_2['durability'] -= card_on_board_1["attack_power"]

        print(f"""
        у гравця 1 залишилось витривалості: {card_on_board_1['durability']}
        у гравця 2 залишилось витривалості: {card_on_board_2['durability']}
        """)
    # перевіряємо яка з карт програла
    if card_on_board_1['durability'] <= 0 and check_if_player_has_cards(player_1):
        print("Карта гравця 1 Вибуває, гравець витягує нову карту")
        card_on_board_1 = player_1.pop()
    elif card_on_board_2['durability'] <= 0 and check_if_player_has_cards(player_2):
        print("Карта гравця 2 Вибуває, гравець витягує нову карту")
        card_on_board_2 = player_2.pop()
    else:
        print("У гравців закінчились карти")
```

"
[Тут](https://github.com/BobasB/2025_kn32_oop/blob/main/3_lab/note.ipynb) детальніше розібрано цей код та його переробка в ООП "


Ось результат коду: 
```plaintext
Гравець 1 робить хід:
Гравець 2 робить хід:
Гравець 1 робить хід:
Гравець 2 робить хід:
Гравець 1 робить хід:
Гравець 2 робить хід:
Карти у руці гравця 1:
        [{'name': 'Сокирка', 'attack_power': 8, 'durability': 36, 'magic_attribute': 'Магія: Вогонь'}, {'name': 'Спис', 'attack_power': 7, 'durability': 34, 'magic_attribute': 'Магія: Вітер'}, {'name': 'Мечик', 'attack_power': 8, 'durability': 32, 'magic_attribute': 'Магія: Земля'}]
    Карти у руці гравця 2:
        [{'name': 'Шпага', 'attack_power': 4, 'durability': 51, 'magic_attribute': 'Магія: Вітер'}, {'name': 'Спис', 'attack_power': 8, 'durability': 54, 'magic_attribute': 'Магія: Вода'}, {'name': 'Мечик', 'attack_power': 6, 'durability': 59, 'magic_attribute': 'Магія: Вода'}]
      

        у гравця 1 залишилось витривалості: 26
        у гравця 2 залишилось витривалості: 51
        

        у гравця 1 залишилось витривалості: 20
        у гравця 2 залишилось витривалості: 43
        

        у гравця 1 залишилось витривалості: 14
        у гравця 2 залишилось витривалості: 35
        

        у гравця 1 залишилось витривалості: 8
        у гравця 2 залишилось витривалості: 27
        

        у гравця 1 залишилось витривалості: 2
        у гравця 2 залишилось витривалості: 19
        

        у гравця 1 залишилось витривалості: -4
        у гравця 2 залишилось витривалості: 11
        

        у гравця 1 залишилось витривалості: -10
        у гравця 2 залишилось витривалості: 3
        

        у гравця 1 залишилось витривалості: -16
        у гравця 2 залишилось витривалості: -5
        
Карта гравця 1 Вибуває, гравець витягує нову карту

        у гравця 1 залишилось витривалості: 28
        у гравця 2 залишилось витривалості: 46
        

        у гравця 1 залишилось витривалості: 20
        у гравця 2 залишилось витривалості: 38
        

        у гравця 1 залишилось витривалості: 12
        у гравця 2 залишилось витривалості: 30
        

        у гравця 1 залишилось витривалості: 4
        у гравця 2 залишилось витривалості: 22
        

        у гравця 1 залишилось витривалості: -4
        у гравця 2 залишилось витривалості: 14
        

        у гравця 1 залишилось витривалості: -12
        у гравця 2 залишилось витривалості: 6
        

        у гравця 1 залишилось витривалості: -20
        у гравця 2 залишилось витривалості: -2
        
Карта гравця 2 Вибуває, гравець витягує нову карту
У гравця 1 не залишилось карт
У гравця 2 не залишилось карт

        у гравця 1 залишилось витривалості: -24
        у гравця 2 залишилось витривалості: 43
        

        у гравця 1 залишилось витривалості: -28
        у гравця 2 залишилось витривалості: 35
        

        у гравця 1 залишилось витривалості: -32
        у гравця 2 залишилось витривалості: 27
        

        у гравця 1 залишилось витривалості: -36
        у гравця 2 залишилось витривалості: 19
        

        у гравця 1 залишилось витривалості: -40
        у гравця 2 залишилось витривалості: 11
        

        у гравця 1 залишилось витривалості: -44
        у гравця 2 залишилось витривалості: 3
        

        у гравця 1 залишилось витривалості: -48
        у гравця 2 залишилось витривалості: -5
        
У гравців закінчились карти
```

як бачимо нам доводилось двічі робити провірку на наявність карт у гравців, що не є оптимальним 
```python
if check_if_player_has_cards(player_1):
        card_on_board_1 = player_1.pop()
    else:
        print("У гравця 1 не залишилось карт")
    
    if check_if_player_has_cards(player_2):
        card_on_board_2 = player_2.pop()
    else:
        print("У гравця 2 не залишилось карт")

```
а у ООП стилі ми б це зробили в методі класу, що є більш оптимальним 
```python
    def draw_card(self):
        if self.has_cards():
            return self.hand.pop()
        else:
            print(f"У гравця {self.name} не залишилось карт")
            return None
```
---

Як бачимо, у процедурному підході нам доводиться повторювати один і той самий код — кожного разу перевіряти, чи є в гравця карти, і лише потім виконувати дію. Це не лише робить код громіздким, а й підвищує ризик помилок при зміні логіки (наприклад, якщо спосіб перевірки наявності карт зміниться, доведеться редагувати її в кількох місцях).

У об’єктно-орієнтованому підході (ООП) ми можемо інкапсулювати поведінку гравця всередині класу. Тобто всі операції, які стосуються конкретного гравця (взяти карту, перевірити кількість карт, додати виграні карти тощо), логічно належать саме цьому об’єкту. Таким чином, ми можемо створити метод draw_card(), який самостійно виконує перевірку і, за необхідності, повідомляє про відсутність карт.

Такий підхід має кілька переваг:

    - Менше дублювання коду — одна перевірка реалізується в одному місці.

    - Легше супроводжувати код — якщо зміниться логіка обробки, достатньо оновити лише метод класу.

    - Покращується читабельність — основний код гри стає коротшим і зрозумілішим.

---

Таким чином, використання ООП дозволяє розділити обов’язки між об’єктами, зробити код більш логічним, гнучким і наближеним до реальних сутностей гри. Це приклад принципу інкапсуляції, коли дані (hand) та методи роботи з ними (draw_card, has_cards) об’єднані в єдину структуру.

Отже, ми бачимо, що при процедурному підході код стає більш громіздким і менш гнучким. Нам доводиться вручну стежити за всіма перевірками, викликами функцій і повтореннями, що збільшує ймовірність помилок і ускладнює розширення програми. Це добре помітно на прикладі перевірки наявності карт у гравців — одну й ту саму логіку доводиться дублювати кілька разів.

Саме тому доцільно перейти до об’єктно-орієнтованого підходу (ООП). У ньому ми описуємо кожного гравця як об’єкт із власними властивостями (наприклад, ім’я та набір карт) і методами (наприклад, draw_card(), has_cards(), add_cards() тощо). Це дозволяє приховати внутрішню логіку роботи з картами всередині класу, а зовнішній код залишити чистим і зрозумілим — достатньо лише викликати потрібний метод об’єкта.

Таким чином, ООП допомагає структурувати програму, розділити відповідальність між окремими об’єктами і зробити код більш гнучким. Якщо згодом зміняться правила гри чи спосіб взаємодії з колодою, достатньо буде оновити лише методи класу, не торкаючись усієї програми. Це спрощує підтримку коду та робить його придатним для подальшого розширення.

Отже, застосування принципів ООП — це не просто інша форма запису, а більш ефективний спосіб організації логіки програми. Завдяки цьому код стає чистішим, зрозумілішим і ближчим до реальних моделей взаємодії об’єктів у світі, що є головною перевагою об’єктно-орієнтованого програмування. 